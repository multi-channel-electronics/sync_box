-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2005 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions
-- and other software and tools, and its AMPP partner logic
-- functions, and any output files any of the foregoing
-- (including device programming or simulation files), and any
-- associated documentation or information are expressly subject
-- to the terms and conditions of the Altera Program License
-- Subscription Agreement, Altera MegaCore Function License
-- Agreement, or other applicable license agreement, including,
-- without limitation, that your use is for the sole purpose of
-- programming logic devices manufactured by Altera and sold by
-- Altera or its authorized distributors.  Please refer to the
-- applicable agreement for further details.


-- Generated by Quartus II Version 5.0 (Build Build 168 06/22/2005)
-- Created on Wed Aug 31 13:21:28 2005

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;


--  Entity Declaration

ENTITY ManchEncode IS
   -- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
   PORT
   (
      Reset       : IN STD_LOGIC;
      Enable      : IN STD_LOGIC;
      Clk50M      : IN STD_LOGIC;
      Clk25M      : IN STD_LOGIC;
      Clk5M       : IN STD_LOGIC;
      --
      isAddr_Zero : IN STD_LOGIC;
      DV_RTS      : IN STD_LOGIC;
      DV_FreeRun  : IN STD_LOGIC;
      FR_Enable   : IN STD_LOGIC;      -- 1 = DV_FreeRun, 0 = DV_RTS
      CmdData  : IN STD_LOGIC_VECTOR(31 downto 0);
      DV_Cntr_Load   : IN STD_LOGIC; -- set frame count reg.
      --
      -- Main outputs
      ManchOut1   : OUT STD_LOGIC;
      ManchOut2   : OUT STD_LOGIC;
      DV_OUT_FTS  : OUT STD_LOGIC;
      DV_OUT_POL  : OUT STD_LOGIC;
      DV_OUT_SPR1 : OUT STD_LOGIC;
      DV_OUT_SPR2 : OUT STD_LOGIC;
      --
      -- Assorted Test-Point & LED outputs.
      DV_Delayed  : OUT STD_LOGIC;
      DV_Error    : OUT STD_LOGIC;
      Manch_NRZ   : OUT STD_LOGIC;
      Manch_Clk   : OUT STD_LOGIC;
      TP_SMA      : OUT STD_LOGIC
      ;
      -- sim & test o/p
      dv_buf_o    : out std_logic;
      xxdv_o      : out std_logic
--    shift_bits_o : out std_logic_vector(39 downto 0)

   );
   -- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END ManchEncode;


--  Architecture Body

ARCHITECTURE P_v5d OF ManchEncode IS

   SIGNAL DV_Cntr    : STD_LOGIC_VECTOR(31 DOWNTO 0); -- frame count reg.
   SIGNAL StatusBits : STD_LOGIC_VECTOR(5 DOWNTO 0); -- spares to total bits-out to 40.
   SIGNAL ShiftBits  : STD_LOGIC_VECTOR(39 DOWNTO 0); -- output shift reg.
   SIGNAL rDV_RTS    : STD_LOGIC;   -- selected input DV source, RTS or FR, active low
   SIGNAL rrDV_RTS      : STD_LOGIC;   -- selected input DV source, RTS or FR, active low
   SIGNAL rrrDV_RTS  : STD_LOGIC;   -- selected input DV source, RTS or FR, active low
   SIGNAL rrrrDV_RTS  : STD_LOGIC;   -- selected input DV source, RTS or FR, active low
   SIGNAL eDV_RTS    : STD_LOGIC;   -- selected input DV source, RTS or FR, active low
   SIGNAL eDV_RTS_temp    : STD_LOGIC;   -- selected input DV source, RTS or FR, active low
   SIGNAL DV_in      : STD_LOGIC;   -- selected input DV source, RTS or FR, active low
-- SIGNAL rDV_in      : STD_LOGIC;  -- clk-synced version of DV_in
-- SIGNAL rrDV_in      : STD_LOGIC;    -- clk-synced version of rDV_in
   SIGNAL DV_Buf     : STD_LOGIC;   -- DV_Buf is low if there was a DV since last isAddr_Zero;
   SIGNAL sDV_Err       : STD_LOGIC;
   --
   --
   signal DV_thin    : STD_LOGIC;   --
   signal DV_out  : STD_LOGIC;   -- active high DV output for FTS, POL, etc.
   signal stout   : STD_LOGIC_VECTOR(6 DOWNTO 0);  -- pulse stretcher for DV_out
   --
   --
   SIGNAL Shift5Load : STD_LOGIC_VECTOR(39 DOWNTO 0); -- 5MHz output buffer reg.
   SIGNAL Shift5Bits : STD_LOGIC_VECTOR(39 DOWNTO 0); -- 5MHz output shift reg.
   SIGNAL Shift5Rdy  : STD_LOGIC;                -- ready flag for 5MHz output load.
   SIGNAL Shift5Got  : STD_LOGIC;                -- gotit flag for 5MHz output load.

   type dvp_states is (IDLE, PAUSE1, PAUSE2, WAIT_FOR_LOW, WAIT_FOR_HIGH);
   signal dvp_current_state   : dvp_states;
   signal dvp_next_state      : dvp_states;

   signal reg : std_logic_vector(9 downto 0);

BEGIN

   -- sim & test o/p
   dv_buf_o <= DV_buf;
--   xxdv_o      <= DV_in;
   xxdv_o      <= eDV_RTS;
--   shift_bits_o <= shiftbits;

   -------------------------------------------------------
   -- buffer and edge-detect for DV-RTS
   --
   edgit: process(Reset, Clk25M)
   BEGIN
      if (Reset = '0')then
         rDV_RTS <= '1';
         rrDV_RTS <= '1';
         rrrDV_RTS <= '1';
         rrrrDV_RTS <= '1';
      elsif (rising_edge(Clk25M)) then
         rDV_RTS  <= DV_RTS;        -- register RTS_DV signal
         rrDV_RTS <= rDV_RTS;
         rrrDV_RTS <= rrDV_RTS;
         rrrrDV_RTS <= rrrDV_RTS;
      end if;
   END process edgit;

   shiftreg: process(Clk25M, Reset)
   begin
      if(Reset = '0') then
         reg <= (others => '1');
      elsif(rising_edge(Clk25M)) then
         reg <= rrDV_RTS & reg(9 downto 1);
      end if;
   end process shiftreg;

   --------------------------------------------------------------------------------------------
   -- Notes (Bryce Burger):
   -- If rDV_RTS is sample n of DV_IN, then at the same time rrDV_RTS is sample n-1.
   -- Thus if a falling edge has occurred between sample n and sample n-1,
   -- then sample n (rDV_RTS) should read 'low' and sample 'n-1' (rrDV_RTS) should read 'high'.
   -- Thus, the logic we are looking for is:
   -- eDV_RTS <= (not rDV_RTS) and rrDV_RTS;
   -- But wait, eDV_RTS is active low, so we want to negate all of the above:
   -- eDV_RTS <= NOT(NOT rrDV_RTS AND rrrDV_RTS);

   -- There is still the problem of missed DV pulses.
   -- It seems that even with double buffering, we occaisionally miss DV pulses.
   -- On the order of 44 DV Pulses over 60,000 frames at 100 Hz.
   -- It turns out that the problem was associated with not detecting DV's on ARZs
   --------------------------------------------------------------------------------------------

   ------------------------------------------------
   -- clocked FSMs, advance the state for both FSMs
   state_FF: process(Clk25M, Reset)
   begin
      if(Reset = '0') then
         dvp_current_state <= IDLE;
      elsif(rising_edge(Clk25M)) then
         dvp_current_state <= dvp_next_state;
      end if;
   end process state_FF;

   state_ns: process(eDV_RTS_temp, dvp_current_state, reg)
   begin
      -- Default assignments
      dvp_next_state <= dvp_current_state;
      case dvp_current_state is
         when WAIT_FOR_LOW =>
            if(reg = "0000000000") then
               dvp_next_state <= WAIT_FOR_HIGH;
            end if;
         when WAIT_FOR_HIGH =>
            if(reg = "1111111111") then
               dvp_next_state <= WAIT_FOR_LOW;
            end if;
         when others =>
            dvp_next_state <= WAIT_FOR_LOW;
      end case;
   end process state_ns;

   state_out: process(eDV_RTS_temp, dvp_current_state, reg)
   begin
      -- Default assignments
      eDV_RTS <= '1';
      case dvp_current_state is
         when WAIT_FOR_LOW =>
            if(reg = "0000000000") then
               eDV_RTS <= '0';
            end if;
         when WAIT_FOR_HIGH =>
            if(reg = "1111111111") then
               null;
            end if;
         when others =>
      end case;
   end process state_out;

   -------------------------------------------------------
   -- select which DV source to use
   --
   DV_in <= DV_FreeRun WHEN (FR_Enable = '1') else eDV_RTS;

   ------------------------------------------------------
   -- if DV_in ocurrs: save it and count it.
   -- Flag two or more occurrences of DV in a frame as an error.
   reg_inst : PROCESS(Clk25M, Reset)
   BEGIN
      IF (Reset = '0') THEN
         DV_Buf   <= '1';
         sDV_Err <= '0';
         DV_Cntr  <= X"00000000";
         StatusBits(2 downto 0) <= B"000";      -- output with+after the DV_Cntr
         StatusBits(5) <= '0';               -- StatusBits(4) <= FR_Enable
                                       -- StatusBits(3) <= sDV_Err
      ELSIF (rising_edge(Clk25M)) THEN
         -- synco_j:  modified this code
         -- If there is a DV, set the DV_Buf
         if(DV_in = '0') then
            DV_Buf <= '0';
         -- If there is an ARZ and no DV, clear the DV_Buf
         elsif(isAddr_Zero = '0') then
            DV_Buf <= '1';
         else
            DV_Buf <= DV_Buf;
         end if;

         if(isAddr_Zero = '0' AND DV_Buf = '0') then  -- count DV
            DV_Cntr <= DV_Cntr + 1;
         elsif (DV_Cntr_Load = '1') then  -- change the DV_Count
            DV_Cntr <= CmdData(31 downto 0);
         else
            DV_Cntr <= DV_Cntr;
         end if;

         if (DV_in = '0' and DV_Buf = '0') THEN    -- if 2 DV occur between AddrZeros
            sDV_Err <= '1';                     -- flag it as an error
         elsif (isAddr_Zero = '0' AND DV_Buf = '1') THEN
            sDV_Err <= '0';                     -- reset the DV_error flag at the next Addr_Zero
         end if;
      END IF;
   END PROCESS reg_inst;

   StatusBits(4) <= FR_Enable;
   StatusBits(3) <= sDV_Err;
   DV_Error <= sDV_Err;



   ------------------------------------------------------
   --
   shifto : PROCESS(Clk25M, Reset)
   BEGIN
      IF (Reset = '0') THEN
         ShiftBits <= (others=>'1');
         Shift5Load <= (others=>'1');
         Shift5Rdy <= '1';
      ELSIF (rising_edge(Clk25M)) THEN
         IF (Enable = '1') THEN
            IF (isAddr_Zero = '0') THEN
               ShiftBits(39) <= '0';                  -- sync bit
               ShiftBits(38) <= DV_Buf;               -- maybe a DV bit [if = '0']
               Shift5Load(39) <= '0';
               Shift5Load(38) <= DV_Buf;
               IF ( DV_Buf = '0') THEN                -- if DV has occured,
                  ShiftBits(37 downto 32) <= StatusBits;  -- put status bits into the stream
                  ShiftBits(31 downto 0) <= DV_Cntr;     -- put DV count into the stream
                  --
                  -- also load the 5MHz NRZ output register
                  -- NOTE: the 5Mhz output gets only the DV info stream,
                  -- but not the occurences of Addr_Zero between DVs
                  Shift5Load(39) <= '0';              --
                  Shift5Load(38) <= DV_Buf;           --
                  Shift5Load(37 downto 32) <= StatusBits;
                  Shift5Load(31 downto 0) <= DV_Cntr;
                  Shift5Rdy <= '1';
               ELSE                                -- else put 1's into the stream
                     ShiftBits(37 downto 0) <= (others=>'1');
               END IF;
            ELSE  -- no AddrZero, just shift all 1's
                     ShiftBits <= ShiftBits(38 downto 0) & '1';
               IF(Shift5Got = '1') THEN Shift5Rdy <= '0'; END IF;
            END IF;
         ELSE
            ShiftBits <= ShiftBits;
         END IF;
      END IF;
   END PROCESS shifto;

   ------------------------------------------------------
   --
   shifto5 : PROCESS(Reset, Clk5M)
   BEGIN
      IF (Reset = '0') THEN
         Shift5Bits <= (others=>'1');
         Shift5Got <= '0';
      ELSIF (rising_edge(Clk5M)) THEN
         IF (Enable = '1') THEN
            IF(Shift5Rdy = '1') THEN
               Shift5Bits(39 downto 0) <= Shift5Load(39 downto 0);
               Shift5Got <= '1';
            ELSE
               IF(Shift5Got = '1') THEN Shift5Got <= '0'; END IF;
                  Shift5Bits <= Shift5Bits(38 downto 0) & '1';
            END IF;
         ELSE
            Shift5Bits <= Shift5Bits;
         END IF;
      END IF;
   END PROCESS shifto5;


   ------------------------------------------------------
   --
   DV_thin <= (NOT isAddr_Zero) AND (NOT DV_Buf);  -- delayed version of DV
   --DV_thin <= NOT DV_in;                   -- when-it-happens version of DV

   DVoutputs : PROCESS(Clk25M, Reset)
   BEGIN
      if  (Reset = '0' ) then
         DV_out   <= '0';
         stout    <= "0000000";

      elsif (rising_edge(Clk25M)) then
         if ( DV_thin = '1' ) then
               stout <= "0011001";  -- = 25, = 1uS
               DV_out <= '0';
         elsif (stout > "000000") then
               stout <= stout - 1;
         elsif (stout = "000000") then
               DV_out <= '1';
         end if;
      end if;
   END PROCESS DVoutputs;

   DV_Delayed  <= (NOT isAddr_Zero) AND (NOT DV_Buf); -- narrow version
   DV_OUT_FTS  <= DV_out ;
   DV_OUT_POL  <= DV_out ;
   --DV_OUT_SPR1 <= DV_out ;
   --DV_OUT_SPR2 <= DV_out ;

   DV_OUT_SPR1 <= Clk5M ;           -- Changes in this version
   DV_OUT_SPR2 <= Shift5Bits(39) ;     -- for Princeton.
   --
   Manch_NRZ   <= ShiftBits(39)  ;
   Manch_Clk   <= Clk25M ;
   TP_SMA      <= ShiftBits(39)  ;


   GenMancho : PROCESS(Clk50M)
   BEGIN
       if rising_edge(Clk50M) then
         ManchOut1 <= Clk25M XOR ShiftBits(39) ;
         ManchOut2 <= Clk25M XOR ShiftBits(39) ;
       end if;
   END PROCESS GenMancho;

END P_v5d;
