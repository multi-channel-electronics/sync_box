-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2005 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions 
-- and other software and tools, and its AMPP partner logic       
-- functions, and any output files any of the foregoing           
-- (including device programming or simulation files), and any    
-- associated documentation or information are expressly subject  
-- to the terms and conditions of the Altera Program License      
-- Subscription Agreement, Altera MegaCore Function License       
-- Agreement, or other applicable license agreement, including,   
-- without limitation, that your use is for the sole purpose of   
-- programming logic devices manufactured by Altera and sold by   
-- Altera or its authorized distributors.  Please refer to the    
-- applicable agreement for further details.


-- Generated by Quartus II Version 5.0 (Build Build 168 06/22/2005)
-- Created on Thu Oct 27 11:32:32 2005


LIBRARY ieee;
USE ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all ;
--use ieee.std_logic_arith.all ;
--use ieee.numeric_std.all ;


-- This version PIO_V3b modified to use all programmed io from the cmd-processor with an 8 bit address,
-- rather than 16 bit address external-memory writes and reads as previous.
-- IO was renamed and re-written to suit.
--		PIO_DAT		: INOUT STD_LOGIC_VECTOR(7 downto 0); = CmdProcessor P0
--		PIO_ADR		: IN STD_LOGIC_VECTOR(7 downto 0);    = CmdProc P2
--		PIO_ALE    	: IN STD_LOGIC;	not used 
--		PIO_nWR     : IN STD_LOGIC; = CmdProc P3.6
--		PIO_nRD     : IN STD_LOGIC; = CmdProc P3.7
--		PIO_Reset	: IN STD_LOGIC; = CmdProc P1.0
--		PIO_nEnable	: IN STD_LOGIC; = CmdProc P1.1


--  Entity Declaration

ENTITY PIO_Interface IS
	GENERIC (
											  -- Address	Function
											  -- -------	--------			
			ADR_xxx 		: integer := 00 ; -- X"0000"	not used
			ADR_CMDSEL 		: integer := 01 ; -- X"0001"	CmdSelect
			ADR_MODEREG 	: integer := 02 ; -- X"0002"	Mode Control Register
			ADR_CMDDATB0 	: integer := 16 ; -- X"0010"	CmdData[7..0]
			ADR_CMDDATB1 	: integer := 17 ; -- X"0011"	CmdData[15..8]
			ADR_CMDDATB2 	: integer := 18 ; -- X"0012"	CmdData[23..16]
			ADR_CMDDATB3 	: integer := 19 ; -- X"0013"	CmdData[31..24]
			ADR_AUXO 		: integer := 32 ; -- X"0020"	AuxOut
			ADR_AUXI 		: integer := 33 ; -- X"0021"	AuxIn
			--
			CMD_SL_LOAD      : STD_LOGIC_VECTOR := X"01";	-- 001
			CMD_FR_LOAD		 : STD_LOGIC_VECTOR := X"02";	-- 010
			CMD_DV_CNTR_LOAD : STD_LOGIC_VECTOR := X"04";	-- 100;
			CMD_CLK_ADJ_DIV_LOAD: STD_LOGIC_VECTOR := X"05" -- 0101
			);

	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT
	(
		PIO_ALE : IN STD_LOGIC;
		PIO_Reset : IN STD_LOGIC;
		PIO_nRD : IN STD_LOGIC;
		PIO_nEnable : IN STD_LOGIC;
		PIO_nWR : IN STD_LOGIC;
		AuxIn : IN STD_LOGIC_VECTOR(8 downto 1);
		Clk25M : IN STD_LOGIC;
		PIO_ADR : IN STD_LOGIC_VECTOR(7 downto 0);
		nRST : IN STD_LOGIC;
		DV_Error : IN STD_LOGIC;
		nPSEN : IN STD_LOGIC;
		PIO_T0 : OUT STD_LOGIC;
		PIO_INT0 : OUT STD_LOGIC;
		PIO_INT1 : OUT STD_LOGIC;
		FR1_Load : OUT STD_LOGIC;
		FR2_Load : OUT STD_LOGIC;
		FR_Enable : OUT STD_LOGIC;
		PIO_T1 : OUT STD_LOGIC;
		SL1_Load : OUT STD_LOGIC;
		SL2_Load : OUT STD_LOGIC;
		Enable : OUT STD_LOGIC;
		AuxOut : OUT STD_LOGIC_VECTOR(8 downto 1);
		Reset : OUT STD_LOGIC;
		DV_Cntr_Load : OUT STD_LOGIC;
		CmdData : OUT STD_LOGIC_VECTOR(31 downto 0);
		clk_adj_div_load : OUT STD_LOGIC;
		PIO_DAT : INOUT STD_LOGIC_VECTOR(7 downto 0)
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
	

-- to setup for normal DV_RTS run:
-- Disable[...]; set RL_Load; set NR_Load; Enable[...].
--
-- to setup for DV_FreeRun mode:
-- Disable[...]; set FR_Load; set RL_Load; set NR_Load; Enable[...].

END PIO_Interface;


--  Architecture Body

ARCHITECTURE PIO_V3b OF PIO_Interface IS

	function match(L, R: std_logic_vector) return std_logic is
    begin
        if L = R then return '1'; 
        else return '0'; 
        end if;
    end match; 


	--signal CmdSelect  	: STD_LOGIC_VECTOR(1 downto 0);	-- Address X"0001"
	signal sReset  		: STD_LOGIC;
	signal AddrReg		: STD_LOGIC_VECTOR(7 downto 0); 
	signal ModeReg		: STD_LOGIC_VECTOR(7 downto 0); 
	signal rPIO_nWR     : STD_LOGIC;
	signal rrPIO_nWR    : STD_LOGIC;
	signal ePIO_WR		: STD_LOGIC;
	signal CmdWrite   	: STD_LOGIC;

	alias Mode_FR_Enable    : STD_LOGIC is ModeReg(0);
	alias Mode_Config_Bank1 : STD_LOGIC is ModeReg(1);
	alias Mode_Config_Bank2 : STD_LOGIC is ModeReg(2);
	
BEGIN

-- unused stuff...
PIO_T0 	<= 'Z';
PIO_T1 	<= 'Z';
PIO_INT1 <= 'Z';

-- Other IO
--PIO_INT0 <= DV_Error;	-- 
PIO_INT0 <= 'Z';	-- 

-- for simulation & test
--ModeReg_o 	<= ModeReg; 
--rPIO_nWR_o 	<= rPIO_nWR;
--rrPIO_nWR_o <= rrPIO_nWR;
--ePIO_WR_o 	<= ePIO_WR;
--CmdWrite_o  <= CmdWrite;

-- Reset and Enable:
-- PIO Initialzes HIGH, But we want them the other way. 
-- Could add external inverters for this, to use the global reset input.
--if (PIO_Reset = '1')  then Reset <= '0'; else Reset <= '1'; end if;
--
Reset <= NOT PIO_Reset;
sReset <= NOT PIO_Reset;
Enable <= NOT PIO_nEnable;
--
-- this group for test without cmd processor software
-- Reset will be off; Enable on
--Reset <= PIO_Reset;		
--sReset <= PIO_Reset;
--Enable <= PIO_nEnable;



GetLowAddr: process(sReset, Clk25M )
BEGIN
	if (sReset = '0' )then 
    	AddrReg <= X"00" ;
	elsif (rising_edge(Clk25M)) then 
		AddrReg   <= PIO_ADR(7 downto 0);	-- register the [low] address byte 
	end if;	
END process GetLowAddr;


-- register the PIO cmddata
GetCmdData: process(sReset, PIO_nWR, AddrReg)
BEGIN
	if (sReset = '0' )then 
    	CmdData <= X"00000000" ;
	elsif (rising_edge(PIO_nWR) and (AddrReg = ADR_CMDDATB0)) then 
		CmdData(7 downto 0) <= PIO_DAT(7 downto 0); 
	elsif (rising_edge(PIO_nWR) and (AddrReg = ADR_CMDDATB1)) then 
		CmdData(15 downto 8) <= PIO_DAT(7 downto 0); 
	elsif (rising_edge(PIO_nWR) and (AddrReg = ADR_CMDDATB2)) then 
		CmdData(23 downto 16) <= PIO_DAT(7 downto 0); 
	elsif (rising_edge(PIO_nWR) and (AddrReg = ADR_CMDDATB3)) then 
		CmdData(31 downto 24) <= PIO_DAT(7 downto 0); 
	end if;
	
END process GetCmdData;


edgit: process(sReset, Clk25M )
BEGIN
	if (sReset = '0' )then 
		rPIO_nWR <= '1';
	elsif (rising_edge(Clk25M)) then 
		rPIO_nWR  <= PIO_nWR;			-- register pio write signal 
		rrPIO_nWR <= rPIO_nWR;		 
	end if;	
END process edgit;

ePIO_WR <= rPIO_nWR AND NOT rrPIO_nWR;	-- use rising edge of PIO_nWR
--ePIO_WR <= NOT rPIO_nWR AND rrPIO_nWR;	-- use falling edge of PIO_nWR


-- generate load signals for various counters
Loadex: process (ePIO_WR, CmdWrite,  AddrReg, PIO_DAT, PIO_nWR)
BEGIN

	if (AddrReg = ADR_CMDSEL and ePIO_WR = '1') then 
		CmdWrite <= '1';
	else 
		CmdWrite <= '0';
	end if;
	
	SL1_Load      <= CmdWrite and match(PIO_DAT, CMD_SL_LOAD) and Mode_Config_Bank1;	-- 001
	SL2_Load      <= CmdWrite and match(PIO_DAT, CMD_SL_LOAD) and Mode_Config_Bank2;	-- 001
	FR1_Load      <= CmdWrite and match(PIO_DAT, CMD_FR_LOAD) and Mode_Config_Bank1;	-- 010
	FR2_Load      <= CmdWrite and match(PIO_DAT, CMD_FR_LOAD) and Mode_Config_Bank2;	-- 010
	DV_Cntr_Load <= CmdWrite and match(PIO_DAT, CMD_DV_CNTR_LOAD); 	-- 100;
	clk_adj_div_load  <= CmdWrite and match(PIO_DAT, CMD_CLK_ADJ_DIV_LOAD); -- 101;
	
END process Loadex ;

-- Set the Mode Flags; only FreeRun_Mode so far
ModeFlags: process (sReset, PIO_nWR, AddrReg)
BEGIN
	if (sReset = '0' )then 
		Mode_FR_Enable <= '0';
		Mode_Config_Bank1 <= '1';
		Mode_Config_Bank2 <= '1';
	elsif (rising_edge(PIO_nWR) and (AddrReg = ADR_MODEREG)) then 
		ModeReg(7 downto 0) <= PIO_DAT(7 downto 0); 
	end if;
	
END process ModeFlags;

FR_Enable <= Mode_FR_Enable;


---------------------------------------------------------------------------------

-- ACDCCU Read Status
AuxInGet: process (PIO_DAT, AddrReg, AuxIn, PIO_nRD)
BEGIN
	if (AddrReg = ADR_AUXI and PIO_nRD = '0') then 
		PIO_DAT <= AuxIn;
	else
		PIO_DAT <= "ZZZZZZZZ";
	end if;

END process AuxInGet;

-- ACDCCU Control Outputs
AuxOutLoad: process (sReset, PIO_DAT, AddrReg, PIO_nWR)
BEGIN
	if (sReset = '0' )then 
    	AuxOut <= X"00" ;
	elsif (rising_edge(PIO_nWR) and (AddrReg = ADR_AUXO)) then 
		AuxOut <= PIO_DAT;
	end if;
END process AuxOutLoad;


END PIO_V3b;
