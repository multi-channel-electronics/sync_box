-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2005 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions 
-- and other software and tools, and its AMPP partner logic       
-- functions, and any output files any of the foregoing           
-- (including device programming or simulation files), and any    
-- associated documentation or information are expressly subject  
-- to the terms and conditions of the Altera Program License      
-- Subscription Agreement, Altera MegaCore Function License       
-- Agreement, or other applicable license agreement, including,   
-- without limitation, that your use is for the sole purpose of   
-- programming logic devices manufactured by Altera and sold by   
-- Altera or its authorized distributors.  Please refer to the    
-- applicable agreement for further details.


-- Generated by Quartus II Version 5.0 (Build Build 168 06/22/2005)
-- Created on Wed Aug 31 13:21:28 2005

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE IEEE.STD_LOGIC_UNSIGNED.ALL;


--  Entity Declaration

ENTITY ManchEncode IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT
	(
		Clk25M 		: IN STD_LOGIC;
		Clk50M 		: IN STD_LOGIC;
		Reset 		: IN STD_LOGIC;
		Enable 		: IN STD_LOGIC;
		--
		isAddr_Zero : IN STD_LOGIC;
		DV_RTS 		: IN STD_LOGIC;
		DV_FreeRun 	: IN STD_LOGIC;
		FR_Enable 	: IN STD_LOGIC;		-- 1 = DV_FreeRun, 0 = DV_RTS
		CmdData 	: IN STD_LOGIC_VECTOR(31 downto 0);
		DV_Cntr_Load	: IN STD_LOGIC; -- set frame count reg.
		--
		-- Main outputs
		ManchOut1 	: OUT STD_LOGIC;
		ManchOut2 	: OUT STD_LOGIC;
		DV_OUT_FTS 	: OUT STD_LOGIC;
		DV_OUT_POL 	: OUT STD_LOGIC;
		DV_OUT_SPR1 : OUT STD_LOGIC;
		DV_OUT_SPR2 : OUT STD_LOGIC;
		--
		-- Assorted Test-Point & LED outputs.
		DV_Delayed	: OUT STD_LOGIC;
		DV_Error 	: OUT STD_LOGIC;
		Manch_NRZ 	: OUT STD_LOGIC;
		Manch_Clk 	: OUT STD_LOGIC;
		TP_SMA 		: OUT STD_LOGIC
		;
		-- sim & test o/p
		dv_buf_o    : out std_logic;
--		dv_wait_o   : out std_logic;
		xxdv_o    	: out std_logic
--		shift_bits_o : out std_logic_vector(39 downto 0)

	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
	
END ManchEncode;


--  Architecture Body

ARCHITECTURE v5d OF ManchEncode IS

	SIGNAL DV_Cntr		: STD_LOGIC_VECTOR(31 DOWNTO 0); -- frame count reg.
	SIGNAL StatusBits	: STD_LOGIC_VECTOR(5 DOWNTO 0); -- spares to total bits-out to 40.
	SIGNAL ShiftBits	: STD_LOGIC_VECTOR(39 DOWNTO 0); -- output shift reg.
	SIGNAL rDV_RTS		: STD_LOGIC; 	-- selected input DV source, RTS or FR, active low
	SIGNAL rrDV_RTS		: STD_LOGIC; 	-- selected input DV source, RTS or FR, active low
	SIGNAL eDV_RTS		: STD_LOGIC; 	-- selected input DV source, RTS or FR, active low
	SIGNAL DV_in		: STD_LOGIC; 	-- selected input DV source, RTS or FR, active low
--	SIGNAL rDV_in      : STD_LOGIC; 	-- clk-synced version of DV_in
--	SIGNAL rrDV_in      : STD_LOGIC; 	-- clk-synced version of rDV_in
	SIGNAL DV_Buf 		: STD_LOGIC; 	-- DV_Buf is low if there was a DV since last isAddr_Zero;
--	SIGNAL DV_Wait 		: STD_LOGIC;
	SIGNAL sDV_Err 		: STD_LOGIC;
	--
	--
	signal DV_thin 	: STD_LOGIC;	-- 
	signal DV_out 	: STD_LOGIC;	-- active high DV output for FTS, POL, etc.
	signal stout	: STD_LOGIC_VECTOR(6 DOWNTO 0);  -- pulse stretcher for DV_out
 
	
BEGIN

	-- sim & test o/p
	dv_buf_o	<= DV_buf;
--	dv_wait_o	<= DV_Wait;
--	xxdv_o		<= DV_in;
	xxdv_o		<= eDV_RTS;
--	shift_bits_o <= shiftbits;

-------------------------------------------------------
-- buffer and edge-detect for DV-RTS
--
edgit: process(Reset, Clk25M )
BEGIN
	if (Reset = '0' )then 
		rDV_RTS <= '1';
	elsif (rising_edge(Clk25M)) then 
		rDV_RTS  <= DV_RTS;			-- register RTS_DV signal 
		rrDV_RTS <= rDV_RTS;		 
	end if;	
END process edgit;

--eDV_RTS <= NOT(rDV_RTS AND NOT rrDV_RTS);	-- use rising edge of DV_RTS
eDV_RTS <= NOT(NOT rDV_RTS AND rrDV_RTS);	-- use falling edge of DV_RTS

-------------------------------------------------------
-- select which DV source to use
--
DV_in <= DV_FreeRun WHEN (FR_Enable = '1') else eDV_RTS;

-------------------------------------------------------
-- double buffer DV_in . 
--
--dubuf1 : PROCESS(Clk25M, Reset)
--BEGIN 	
 --	IF (Reset = '0') THEN 
--		rDV_in  <= '1';		
--	ELSIF (falling_edge(Clk25M)) THEN
--		rDV_in <= DV_in;
--	END IF;
--END PROCESS dubuf1;
	
--dubuf2 : PROCESS(Clk25M, Reset)
--BEGIN 	
-- 	IF (Reset = '0') THEN 
--		rrDV_in  <= '1';		
--	ELSIF (rising_edge(Clk25M)) THEN
--		rrDV_in <= rDV_in;
--	END IF;
--END PROCESS dubuf2;

	
------------------------------------------------------
-- if DV_in ocurrs: save it and count it. 
-- Flag two or more occurrences of DV in a frame as an error.
reg : PROCESS(Clk25M, Reset)
BEGIN 	
 	IF (Reset = '0') THEN 
		DV_Buf   <= '1';
		sDV_Err <= '0';
		DV_Cntr  <= X"00000000";
		StatusBits(2 downto 0) <= B"000";		-- output with+after the DV_Cntr
		StatusBits(5) <= '0';					-- StatusBits(4) <= FR_Enable
												-- StatusBits(3) <= sDV_Err		
	ELSIF (rising_edge(Clk25M)) THEN		
		if(isAddr_Zero = '0') then  -- clears the dv_buf
			DV_Buf <= '1';
		elsif(DV_in = '0') then		-- if a DV has occured, record it.
			DV_Buf <= '0';
		else
			DV_Buf <= DV_Buf;
		end if;
		
		if(isAddr_Zero = '0' AND DV_Buf = '0') then  -- count DV
			DV_Cntr <= DV_Cntr + 1;
		elsif (DV_Cntr_Load = '1') then 	-- change the DV_Count
			DV_Cntr <= CmdData(31 downto 0);
		else
			DV_Cntr <= DV_Cntr;
		end if;
		
--		if(DV_in = '1' AND DV_Buf = '0') then
--			DV_Wait <= '1';
--		else
--			DV_Wait <= '0';
--		end if;
		
--		if (DV_in = '0' and DV_Wait = '1') THEN		-- if 2 DV occur between AddrZeros
		if (DV_in = '0' and DV_Buf = '0') THEN		-- if 2 DV occur between AddrZeros
			sDV_Err <= '1';							-- flag it as an error
		elsif (isAddr_Zero = '0' AND DV_Buf = '1') THEN
			sDV_Err <= '0';							-- reset the error flag
		end if;				
	END IF;

END PROCESS reg;

StatusBits(4) <= FR_Enable;
StatusBits(3) <= sDV_Err;
DV_Error <= sDV_Err;
			

shifto : PROCESS(Clk25M, Reset)
BEGIN
 	IF (Reset = '0') THEN 
		ShiftBits <= (others=>'1');
		--ShiftBits <= (others=>'0');
	ELSIF (rising_edge(Clk25M)) THEN		
		IF (Enable = '1') THEN
			IF (isAddr_Zero = '0') THEN
				ShiftBits(39) <= '0';						-- sync bit
				ShiftBits(38) <= DV_Buf;					-- maybe a DV bit [if = '0'] 
				IF ( DV_Buf = '0') THEN  					-- if DV has occured,
    	 			ShiftBits(37 downto 32) <= StatusBits;  -- put status bits into the stream
  	 				ShiftBits(31 downto 0) <= DV_Cntr;  	-- put DV count into the stream
				ELSE  										-- else put 1's into the stream
   	  				ShiftBits(37 downto 0) <= (others=>'1');
				END IF;
			ELSE 	-- no AddrZero, just shift all 1's 
   	      		ShiftBits <= ShiftBits(38 downto 0) & '1';
			END IF;
		ELSE
			ShiftBits <= ShiftBits;
		END IF;
	END IF;
END PROCESS shifto;


DV_thin <= (NOT isAddr_Zero) AND (NOT DV_Buf);	-- delayed version of DV
--DV_thin <= NOT DV_in;							-- when-it-happens version of DV

DVoutputs : PROCESS(Clk25M, Reset)
BEGIN	
	if  (Reset = '0' ) then
		DV_out 	<= '0';
		stout 	<= "0000000";
		
	elsif (rising_edge(Clk25M)) then
		if ( DV_thin = '1' ) then 
				stout <= "0011001";	-- = 25, = 1uS
				DV_out <= '0'; 
		elsif (stout > "000000") then
				stout <= stout - 1; 
		elsif (stout = "000000") then
				DV_out <= '1'; 
		end if; 
	end if; 
END PROCESS DVoutputs;

DV_Delayed  <= (NOT isAddr_Zero) AND (NOT DV_Buf); -- narrow version
DV_OUT_FTS 	<= DV_out ;
DV_OUT_POL 	<= DV_out ;
--DV_OUT_SPR1 <= DV_out ;
--DV_OUT_SPR2 <= DV_out ;

DV_OUT_SPR1 <= Clk25M ;				-- Changes in this version
DV_OUT_SPR2 <= ShiftBits(39) ;		-- for Princeton.
--
Manch_NRZ	<= ShiftBits(39)	;
Manch_Clk 	<= Clk25M ;
TP_SMA		<= ShiftBits(39)	;


GenMancho : PROCESS(Clk50M)
BEGIN
    if rising_edge(Clk50M) then
		ManchOut1 <= Clk25M XOR ShiftBits(39) ;
		ManchOut2 <= Clk25M XOR ShiftBits(39) ;
    end if;
END PROCESS GenMancho;

END v5d;
