C51 COMPILER V8.02   SYNCOCMD                                                              02/23/2010 09:00:13 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE SYNCOCMD
OBJECT MODULE PLACED IN .\output\SyncoCmd.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SyncoCmd.c COMPACT ROM(COMPACT) BROWSE MODP2 DEBUG OBJECTEXTEND PRINT(.\out
                    -put\SyncoCmd.lst) OBJECT(.\output\SyncoCmd.obj)

line level    source

   1          /*==========================================================================*
   2           * SyncoCmd.c                                                                                                                           *
   3           * main() and  command io routines.                                                                             *
   4           *==========================================================================*
   5           * First Version for SC2: SyncoCmd-V1a RHJ 1-May-06
   6           * SyncoCmd-V1b RHJ 17-Aug-06   - minor cosmetic changes and additions.
   7           * 22-Oct-06 RHJ                                - added pwr_status() command function.
   8           *
   9           *
  10           */
  11          
  12          #define  SYNCOMAIN
  13          
  14          #include <AT89c5131.h>
  15          #include <stdio.h>
  16          #include <intrins.h>
  17          #include "SyncoCmd.h"
  18          
  19          
  20          
  21          /*---------- Function prototypes */
  22          
  23          void prt_toosmall(int i);
  24          void prt_toobig(int i);
  25          void prt_minsync(void);
  26          void chk_switches(void);
  27          //
  28          void do_ResetAll(void);
  29          void set_Enable(void);
  30          void set_Disable(void);
  31          void get_Status(void);
  32          void set_Row_Len(void);
  33          void set_Num_Rows(void);
  34          void set_FR_Mode(void);
  35          void set_RTS_Mode(void);
  36          void set_Frame_Num(void);
  37          void set_clk_adj_div(void);
  38          void pwr_enable(void);
  39          void pwr_disable(void);
  40          void pwr_status(void);
  41          
  42          
  43          /*=============================================================================================*/
  44          /*---------- Variable Value Defines */
  45          #define  FRUN_DV                (unsigned char)1
  46          #define  RTS_DV                 (unsigned char)0
  47          //
  48          // Default values for start & reset
  49          //#define  FRUN_COUNT           3       // This group for test.
  50          //#define  ROWLEN                       64
  51          //#define  NUMROW                       2
  52          //
  53          //#define  FRUN_COUNT           30      // This group for Princeton.
  54          //#define  ROWLEN                       50  // 100 cycles of 50MHz
C51 COMPILER V8.02   SYNCOCMD                                                              02/23/2010 09:00:13 PAGE 2   

  55          //#define  NUMROW                       41
  56          //
  57          #define  FRUN_COUNT             47      // about 200 Hz DV rate
  58          #define  ROWLEN                 64
  59          #define  NUMROW                 41
  60          #define  CLKADJDIV      10  // default divisor for adjustable clk frequency clk_adj_div
  61          
  62          // min-max values for cmd input
  63          #define  MINROWLEN               1      // rowlen setable 50 -> 4095
  64          #define  MAXROWLEN        4095
  65          #define  MINNUMROW               1      // numrow setable 1 -> 63
  66          #define  MAXNUMROW              63
  67          #define  MINSYNCLEN             250     // rowlen * numrow must be > 250
  68          #define  MINFRCNT                1      // DV_FRUN output 1 to 4095 occurances of AddrZero
  69          #define  MAXFRCNT         4095
  70          #define  MINDIV       1     // Minimum 50MHz division ratio for adjustable clk outputs
  71          #define  MAXDIV       255   // Maximum 50MHz division ratio for adjustable clk outputs
  72          
  73          
  74          /*=============================================================================================*/
  75          /*---------- Global variables---------------*/
  76          /*  FOR STARTUP DEFAULTS, SEE: do_ResetAll() */
  77          bit sc_mancho_enable;                   // flag bit for whether manchester output is running or not
  78          int sc_FRun_Count;                              // AddrZero count for output of a DV_FreeRun
  79          int sc_row_len;                                 // Default Row_Length
  80          unsigned char sc_num_row;               // Default SyncLength = (num_row * row_len) - 1
  81          unsigned char sc_mancho_mode;   // mode control byte; is DV source DV_FreeRun or DV_RTS
  82          unsigned char sc_ACDCU_onoff = 0;       // all ACDCCU off
  83          int sc_clk_adj_div;             // Default divisor for the adjustable clock frequency
  84          
  85          char code version[] =  "\r\tSyncoCmd-V1f\r";
  86          char code prompt[] = "\rSynco> ";
  87          
  88          /*=============================================================================================*/
  89          //--------
  90          void do_ResetAll(void)
  91          {
  92   1      //sc_mancho_mode = RTS_DV;
  93   1      sc_mancho_mode = FRUN_DV;
  94   1      sc_FRun_Count = FRUN_COUNT;
  95   1      sc_row_len = ROWLEN;
  96   1      sc_num_row = NUMROW;
  97   1      sc_mancho_enable = TRUE;        //
  98   1      sc_clk_adj_div = CLKADJDIV;
  99   1      //
 100   1      pio_nEnable(OFF);       //
 101   1      pio_Reset((bit)ON);
 102   1      pio_Reset((bit)OFF);
 103   1      pio_SyncLength((sc_row_len*sc_num_row)-1);
 104   1      pio_FRun_Count(sc_FRun_Count-1);
 105   1      pio_clk_adj_div(sc_clk_adj_div);
 106   1      pio_DV_Mode(sc_mancho_mode);
 107   1      pio_FrameNum((unsigned long)0);
 108   1      pio_nEnable(sc_mancho_enable);  //
 109   1      }
 110          
 111          /*=============================================================================================*/
 112          
 113          void main (void)
 114          {
 115   1      
 116   1      sio_Init_9600();
C51 COMPILER V8.02   SYNCOCMD                                                              02/23/2010 09:00:13 PAGE 3   

 117   1      TI = 1 ;
 118   1      //Timer0_Init();        // not used. code is in sio.c
 119   1      //
 120   1      printf("%s", version);
 121   1      cd_help();
 122   1      printf("%s", prompt);
 123   1      do_ResetAll();
 124   1      
 125   1      while(1)                        // endless
 126   1              {
 127   2      //      testxx();               // test & debug stuff.
 128   2      
 129   2              if(sio_rx_gotcl == TRUE)
 130   2                      {                                                                       // got a cmd line
 131   3                      sio_rx_gotcl = FALSE;
 132   3                      ES = OFF;                                                       // disable serial interrupt
 133   3                      cd_tokenize(sio_rxbuf);                         // parse a command line
 134   3                      cd_parse(cmd_dict, dict_size);
 135   3                      sio_rx_idx = 0;                                         // reset message pointer
 136   3                      ES = ON;                                                        // Enable serial interrupt
 137   3                      printf("%s", prompt) ;
 138   3                      }
 139   2      //      chk_switches();
 140   2              }
 141   1      }
 142          
 143          
 144          /*========== Utility Functions for command variable range errors =====================*/
 145          
 146          //--------
 147          void prt_needarg(void)
 148          { printf("\tARGUMENT REQUIRED"); }
 149          
 150          //--------
 151          void prt_toosmall(int i)
 152          { printf("\tTOO SMALL \"%d\"", i); }
 153          
 154          //--------
 155          void prt_toobig(int i)
 156          { printf("\tTOO BIG \"%d\"", i); }
 157          
 158          //--------
 159          void prt_minsync(void)
 160          { int i = MINSYNCLEN; printf("\tROWLEN * NUMROW MUST BE >= %d", i); }
 161          
 162          
 163          /*========== Command Dictionary Functions  ===============================*/
 164          
 165          
 166          //--------
 167          void set_Enable(void)
 168          {
 169   1      sc_mancho_enable = TRUE;
 170   1      pio_nEnable(ON);
 171   1      }
 172          
 173          //--------
 174          void set_Disable(void)
 175          {
 176   1      sc_mancho_enable = FALSE;
 177   1      pio_nEnable(OFF);
 178   1      }
C51 COMPILER V8.02   SYNCOCMD                                                              02/23/2010 09:00:13 PAGE 4   

 179          
 180          //--------
 181          void get_Status(void)
 182          {
 183   1      code char fr_str[] = "FreeRun_DV";
 184   1      code char rt_str[] = "RTS_DV";
 185   1      char *dvm;
 186   1      code char ena_str[] = "ON";
 187   1      code char dis_str[] = "OFF";
 188   1      char *is_run;
 189   1      
 190   1      if(sc_mancho_enable == TRUE)
 191   1              is_run = ena_str;
 192   1      else
 193   1              is_run = dis_str;
 194   1      
 195   1      if(sc_mancho_mode == FRUN_DV)
 196   1              dvm = fr_str;
 197   1      else
 198   1              dvm = rt_str;
 199   1      
 200   1      putchar('\r');
 201   1      printf("\tMancho_Enable\t= %s\r", is_run);
 202   1      printf("\tDV_Mode\t\t= %s\r", dvm);
 203   1      if(sc_mancho_mode == FRUN_DV)
 204   1              printf("\tFRun_Count\t= %d\r", sc_FRun_Count);
 205   1      printf("\tRow_Len\t\t= %d\r", sc_row_len);
 206   1      printf("\tNum_Row\t\t= %d\r", (int)sc_num_row);
 207   1      printf("\tAdjustable Clock frequency divisor\t\t=%d\r", sc_clk_adj_div);
 208   1      printf("\tACDCU_onoff\t= %#2.2X\r", (int)sc_ACDCU_onoff);
 209   1      
 210   1      }
 211          
 212          //--------
 213          void set_Row_Len(void)
 214          {
 215   1      int rl;
 216   1      unsigned long sl;
 217   1      
 218   1      rl = cd_arg_i();
 219   1      if(rl == -2 ) {prt_needarg(); return;}  // if rl = -2 [= no arg], then error msg
 220   1      if(rl < 0 ) {return;}                                   // if rl = -1 [= not a digit arg], then just ignor
 221   1      if(rl < MINROWLEN ) {prt_toosmall(rl); return;}
 222   1      if(rl > MAXROWLEN ) {prt_toobig(rl); return;}
 223   1      sl = (long)rl * (long)sc_num_row;
 224   1      if(sl < MINSYNCLEN ) {prt_minsync(); return;}
 225   1      
 226   1      sc_row_len = rl;                                        // everything ok, set as the new row_len
 227   1      pio_nEnable(OFF);                                       //
 228   1      pio_SyncLength(sl - 1);                         // minus 1 because counter includes zero
 229   1      pio_nEnable(sc_mancho_enable);          //
 230   1      }
 231          
 232          //--------
 233          void set_Num_Rows(void)
 234          {
 235   1      int nr;
 236   1      unsigned long sl;
 237   1      
 238   1      nr = cd_arg_i();
 239   1      if(nr == -2 ) {prt_needarg(); return;}
 240   1      if(nr < 0 ) {return;}
C51 COMPILER V8.02   SYNCOCMD                                                              02/23/2010 09:00:13 PAGE 5   

 241   1      if(nr < MINNUMROW ) {prt_toosmall(nr); return;}
 242   1      if(nr > MAXNUMROW ) {prt_toobig(nr); return;}
 243   1      sl = (long)nr * (long)sc_row_len;
 244   1      if(sl < MINSYNCLEN ) {prt_minsync(); return;}
 245   1      
 246   1      sc_num_row = (unsigned char)nr; //
 247   1      pio_nEnable(OFF);                               //
 248   1      pio_SyncLength(sl - 1);                 // minus 1 because counter includes zero
 249   1      pio_nEnable(sc_mancho_enable);  //
 250   1      }
 251          
 252          //--------
 253          void set_FR_Mode(void)
 254          {
 255   1      int frc;
 256   1      
 257   1      frc = cd_arg_i();
 258   1      //printf("\targ = %d\r", frc);
 259   1      if(frc >= 0)
 260   1              {
 261   2              if(frc < MINFRCNT ) {prt_toosmall(frc); return;}
 262   2              if(frc > MAXFRCNT ) {prt_toobig(frc); return;}
 263   2              sc_FRun_Count = frc;
 264   2              }
 265   1      
 266   1      // if arg = -1 [= not a digit arg], then just ignor
 267   1      // if arg = -2 [= no arg], then use previous sc_FRUN_COUNT
 268   1      if(frc < 0)
 269   1              {
 270   2              if(frc == -1)
 271   2                      return;
 272   2              else
 273   2                      frc = sc_FRun_Count;
 274   2              }
 275   1      
 276   1      sc_mancho_mode = FRUN_DV;                       //
 277   1      pio_nEnable(OFF);                                       //
 278   1      pio_FRun_Count(frc-1);                          // minus 1 because counter includes zero
 279   1      //pio_DV_Mode(sc_mancho_mode);          // maybe sometime use the other mode bits for extra functions
 280   1      pio_DV_Mode((unsigned char)0xff);       // but for now we will flip all bits
 281   1      pio_nEnable(sc_mancho_enable);          //
 282   1      }
 283          
 284          //-------- switch to RTS_DV mode
 285          void set_RTS_Mode(void)
 286          {
 287   1      sc_mancho_mode = RTS_DV;
 288   1      pio_nEnable(OFF);                                       //
 289   1      //pio_DV_Mode(sc_mancho_mode);          //
 290   1      pio_DV_Mode((unsigned char)0x00);       //
 291   1      pio_nEnable(sc_mancho_enable);          //
 292   1      }
 293          
 294          //-------- set the Frame_Number/DV_Count
 295          void set_Frame_Num(void)
 296          {
 297   1      int r;
 298   1      unsigned long fn;
 299   1      
 300   1      r = cd_arg_ul(&fn);
 301   1      if(r == -2 ) {prt_needarg(); return;}
 302   1      if(r < 0) return;
C51 COMPILER V8.02   SYNCOCMD                                                              02/23/2010 09:00:13 PAGE 6   

 303   1      
 304   1      //printf("\tfn = %lu", fn);
 305   1      pio_nEnable(OFF);                               //
 306   1      pio_FrameNum(fn);
 307   1      pio_nEnable(sc_mancho_enable);  //
 308   1      }
 309          //-------- set the 50MHz/div for DV_SPARE2 output
 310          void set_clk_adj_div(void)
 311          {
 312   1      int r;
 313   1      int clk_adj_div_temp;
 314   1      
 315   1      clk_adj_div_temp = cd_arg_i();
 316   1      if(clk_adj_div_temp >= 0)
 317   1              {
 318   2              if(clk_adj_div_temp < MINDIV ) {prt_toosmall(clk_adj_div_temp); return;}
 319   2              if(clk_adj_div_temp > MAXDIV ) {prt_toobig(clk_adj_div_temp); return;}
 320   2              sc_clk_adj_div = clk_adj_div_temp;
 321   2              }
 322   1      
 323   1      // pio_nEnable(OFF);                            //
 324   1      pio_clk_adj_div(sc_clk_adj_div);
 325   1      // pio_nEnable(sc_mancho_enable);       //
 326   1      }
*** WARNING C280 IN LINE 312 OF SYNCOCMD.C: 'r': unreferenced local variable
 327          //-------- enable a particular ACDCU [sequencing all units on is left up to the user]
 328          void pwr_enable_unit(void)
 329          {
 330   1      int unit_num;
 331   1      unsigned char unit_bit = 1;
 332   1      unsigned char f;
 333   1      
 334   1      unit_num = cd_arg_i();
 335   1      if(unit_num == -2 ) {prt_needarg(); return;}
 336   1      if(unit_num < 0 ) return;
 337   1      if(unit_num > 7 ) {prt_toobig(unit_num); return;}
 338   1      
 339   1      unit_bit = (unit_bit<<unit_num);        // shift bit into the proper position
 340   1      f = (sc_ACDCU_onoff & unit_bit);
 341   1      //printf("\r\tonoff = %#2.2X, ub = %#2.2X, f = %#2.2X\r", (int)sc_ACDCU_onoff, (int)unit_bit, (int)f);
 342   1      if( f > 0 ) {printf("\tALREADY ON"); return;}
 343   1      
 344   1      sc_ACDCU_onoff |= unit_bit;                             //  & save it
 345   1      pio_pwr_onoff(sc_ACDCU_onoff);
 346   1      }
 347          
 348          //-------- disable all ACDCU
 349          void pwr_disable_all(void)
 350          {
 351   1      sc_ACDCU_onoff = 0x00;
 352   1      pio_pwr_onoff(sc_ACDCU_onoff);
 353   1      }
 354          
 355          //-------- disable a particular ACDCU
 356          void pwr_disable_unit(void)
 357          {
 358   1      int unit_num;
 359   1      unsigned char unit_bit = 1;
 360   1      unsigned char f;
 361   1      
 362   1      unit_num = cd_arg_i();
 363   1      if(unit_num == -2 ) {prt_needarg(); return;}
C51 COMPILER V8.02   SYNCOCMD                                                              02/23/2010 09:00:13 PAGE 7   

 364   1      if(unit_num < 0 ) return;
 365   1      if(unit_num > 7 ) {prt_toobig(unit_num); return;}
 366   1      
 367   1      unit_bit = (unit_bit<<unit_num);                // shift & clear bit in the proper position
 368   1      f = (sc_ACDCU_onoff & unit_bit);
 369   1      if(f == 0 ) {printf("\tALREADY OFF"); return;}
 370   1      
 371   1      sc_ACDCU_onoff &= ~unit_bit;                            //  & save it
 372   1      pio_pwr_onoff(sc_ACDCU_onoff);
 373   1      }
 374          
 375          //-------- output the current ACDCU onoff control byte.
 376          void pwr_onoff(void)
 377          {
 378   1      printf("\r\tACDCU_onoff\t= %#2.2X\r", (int)sc_ACDCU_onoff);
 379   1      }
 380          
 381          //-------- read and output the ACDCU status byte.
 382          void pwr_status(void)
 383          {
 384   1      unsigned char pwr_stat;
 385   1      
 386   1      pwr_stat = pio_pwr_status();
 387   1      printf("\r\tACDCU_Status = %#2.2X\r", (int)pwr_stat);
 388   1      }
 389          
 390          /*====Unused and test code ============================================================*/
 391          
 392          /*
 393          //--------
 394          void ResetOn(void)
 395          {
 396          pio_Reset((bit)ON);
 397          }
 398          
 399          //--------
 400          void ResetOff(void)
 401          {
 402          pio_Reset((bit)OFF);
 403          }
 404          */
 405          
 406          /*
 407          //--------
 408          void chk_switches()
 409          {
 410          pio_RdSwitches();
 411          }
 412          */
 413          
 414          /*
 415          void testxx(void )      // assorted code bits & variables for testing
 416          {
 417                  static unsigned char ub;
 418          //      static int i;
 419          //      static unsigned long ul;
 420          
 421                  ES = OFF;       // serial interrupts off for speed.
 422          
 423          //  pio_Reset((bit)OFF);
 424          //  pio_Reset((bit)ON);
 425          //  pio_Reset((bit)OFF);
C51 COMPILER V8.02   SYNCOCMD                                                              02/23/2010 09:00:13 PAGE 8   

 426          //  pio_Reset((bit)ON);
 427          //  pio_nEnable((bit)OFF);
 428          //  pio_nEnable((bit)ON);
 429          //  pio_nEnable((bit)OFF);
 430          //  pio_nEnable((bit)ON);
 431          //
 432          //      pio_Frun_Count(i++);
 433          //      pio_FrameNum(ul++);
 434          //      pio_SyncLength(ul++);
 435          pio_DV_Mode(ub++);
 436          //      pio_pwr_onoff(ub++);
 437          //      ub = pio_pwr_status();
 438          
 439                  ES = ON;
 440          //
 441          }
 442          */
 443          
 444          /*===================== EOF ==========================================*/
 445          
 446          
 447          
 448          
 449          
 450          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1524    ----
   CONSTANT SIZE    =    359    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      9      36
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
