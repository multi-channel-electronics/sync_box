C51 COMPILER V8.04   PIOLIB                                                                09/26/2014 14:38:04 PAGE 1   


C51 COMPILER V8.04, COMPILATION OF MODULE PIOLIB
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE piolib.c COMPACT ROM(COMPACT) BROWSE MODP2 DEBUG OBJECTEXTEND PRINT(.\outpu
                    -t\piolib.lst) OBJECT(.\output\piolib.obj)

line level    source

*** WARNING C500 IN LINE 1 OF PIOLIB.C: LICENSE ERROR (R215: CURRENTLY NO LICENSE AVAILABLE)

   1          /*==========================================================================*
   2           * piolib.c                                                                                                                                     *
   3           * interface to the Mancho CPLD.                                                                                *
   4           *==========================================================================*
   5           * First version: RHJ 9-June-06
   6           *
   7           *
   8           */
   9          
  10          #define  PIOLIB
  11          
  12          #include <AT89c5131.h>
  13          #include <stdio.h>
  14          #include <intrins.h>
  15          
  16          #include "SyncoCmd.h"
  17          
  18          
  19          /*---------- Function prototypes */
  20          void pio_Reset(bit b);
  21          void pio_nEnable(bit b);
  22          void pio_SyncLength(unsigned long sl);
  23          void pio_FrameNum(unsigned long fn);
  24          void pio_DV_Mode(unsigned char mode);
  25          void pio_FRun_Count(int frc);
  26          void pio_clk_adj_div(int clk_adj_div);
  27          //void pio_RdSwitches();
  28          void pio_pwr_onoff(unsigned char enbits);
  29          unsigned char pio_pwr_status(void);
  30          void pio_Chk_PSCool();
  31          
  32          /*=========================================================================================*/
  33          /*---------- PIO Interface Defines; See also PIO_Interface.vhd */
  34          /*
  35          P1.0            = PIO_Reset
  36          P1.1            = PIO_nEnable
  37          P1.2 to P1.5 = switches input [not used]
  38          P1.6            =  [not used]
  39          P1.7            =  Spare opto-isolated TTL Input. [not used]
  40                  -----------------
  41          P3.0            = RS232_RXD,
  42          P3.1            = RS232_TXD,
  43          P3.2 to P3.5 = Interrupts & timers,
  44          P3.6            = PIO_nWR,
  45          P3.7            = PIO_nRD.
  46          */
  47          
  48          #define PIO_DAT P0
  49          #define PIO_ADR P2
  50          
  51          sbit PIO_RESET  =       P1^0;           // outputs init high, so initial state is reset,
  52          sbit PIO_nENABLE =      P1^1;           // and clocking disabled.
  53          sbit PIO_SW4    =       P1^2;           // [not used]
C51 COMPILER V8.04   PIOLIB                                                                09/26/2014 14:38:04 PAGE 2   

  54          sbit PIO_SW3    =       P1^3;           // [not used]
  55          sbit PIO_SW2    =       P1^4;           // [not used]
  56          sbit PIO_SW1    =       P1^5;           // [not used]
  57          sbit PIO_PSCOOL =       P1^7;           // [not used] [was 'cooling interlock', is now 'spare opto-TTL input']
  58          //
  59          sbit PIO_nINT0  =       P3^2;           // [not used]
  60          sbit PIO_nINT1  =       P3^2;           // [not used]
  61          sbit PIO_T0             =       P3^4;           // [not used]
  62          sbit PIO_T1             =       P3^5;           // [not used]
  63          sbit PIO_nWR    =       P3^6;           //
  64          sbit PIO_nRD    =       P3^7;           //
  65          
  66          // PIO CPLD/Firmware register address definitions. See also PIO_Interface.vhd
  67          #define  ADR_xxx                00 // -- X"0000"        xxx
  68          #define  ADR_CMDSEL     01 // -- X"0001"        Cmd function Select
  69          #define  ADR_MODEREG    02 // -- X"0002"        Mode Control Register
  70          #define  ADR_CMDDATB0   16 // -- X"0010"        CmdData[7..0]
  71          #define  ADR_CMDDATB1   17 // -- X"0011"        CmdData[15..8]
  72          #define  ADR_CMDDATB2   18 // -- X"0012"        CmdData[23..16]
  73          #define  ADR_CMDDATB3   19 // -- X"0013"        CmdData[31..24]
  74          #define  ADR_AUXO               32 // -- X"0020"        AuxOut
  75          #define  ADR_AUXI               33 // -- X"0021"        AuxIn
  76          //
  77          // CmdSelect reg control vaules
  78          #define  SLEN_LOAD              1       // Load SyncLength counter
  79          #define  FRUN_LOAD              2       // FreeRun counter
  80          #define  DVCNTR_LOAD    4       // DV, FrameNumber, counter
  81          #define  CLK_ADJ_DIV_LOAD   5   // adjustable clock frequency divisor
  82          //
  83          // Mode Control Select Reg., RTS_DV or FRUN_DV control bit; 1 = FR_Enable
  84          #define  MODE_DV                00
  85          
  86          
  87          /*-------------------------------------------------------------------------------------------*/
  88          /* To write to a Mancho-CPLD reg, first write the value bytes into the CmdData reg,
  89           * then write the appropriate select byte to the CmdSelect register.
  90           */
  91          //      if (LowAddr = ADR_CMDSEL and PIO_A = X"00" and PIO_nWR = '0') then
  92          //              CmdWrite <= '1';
  93          //      else
  94          //              CmdWrite <= '0';
  95          //      end if;
  96          //      SL_Load      <= CmdWrite and match(PIO_AD, (X"01"));    -- 001
  97          //      FR_Load      <= CmdWrite and match(PIO_AD, (X"02"));    -- 010
  98          //      DV_Cntr_Load <= CmdWrite and match(PIO_AD, (X"04"));    -- 100;
  99          //      clk_adj_div_load <= CmdWrite and match(PIO_AD, (X"05"));-- 101;
 100          //
 101          //  bit 0 of the ModeReg controls whether FreeRun or RTS DV is used.
 102          //      FR_Enable <= ModeReg(0);
 103          
 104          
 105          /*=========================================================================================*/
 106          /* The 8051 is big-endian,
 107           * the cpld will be addressed as little-endian,
 108           * so the byte order must be reversed when writing to the CPLD CMDDATA.
 109           *
 110           * In this version of SyncoCmd, P0 is used for data io, P2 for an 8 bit address
 111           */
 112          
 113          union
 114               {
 115               unsigned long l_cnt;
C51 COMPILER V8.04   PIOLIB                                                                09/26/2014 14:38:04 PAGE 3   

 116               int i_cnt;
 117               unsigned char bytes[4];
 118               }  piodata;
 119          
 120          #define PDB0 piodata.bytes[0]
 121          #define PDB1 piodata.bytes[1]
 122          #define PDB2 piodata.bytes[2]
 123          #define PDB3 piodata.bytes[3]
 124          
 125          
 126          
 127           /*-------------------------------------------------------------------------------------------*/
 128          
 129          /*-----  */
 130          void
 131          pio_Reset(bit b)
 132          {
 133   1      PIO_RESET = b;          //
 134   1      }
 135          
 136          /*-----   */
 137          void
 138          pio_nEnable(bit b)
 139          {
 140   1      if(b==ON)
 141   1              PIO_nENABLE = 0;                // note that nEnable is active low
 142   1      else
 143   1              PIO_nENABLE = 1;
 144   1      }
 145          
 146          /*----- set the sync length count */
 147          void
 148          pio_SyncLength(unsigned long sl)
 149          {
 150   1      piodata.l_cnt = sl;
 151   1      
 152   1      //printf("\tSL = %d", piodata.i_cnt);
 153   1      
 154   1      // first load the count to the CmdData reg.
 155   1      PIO_ADR = ADR_CMDDATB0;
 156   1      PIO_DAT = PDB3;
 157   1      _nop_ ();
 158   1      PIO_nWR = LOW;
 159   1      PIO_nWR = HIGH;
 160   1      PIO_ADR = ADR_CMDDATB1;
 161   1      PIO_DAT = PDB2;
 162   1      _nop_ ();
 163   1      PIO_nWR = LOW;
 164   1      PIO_nWR = HIGH;
 165   1      PIO_ADR = ADR_CMDDATB2;
 166   1      PIO_DAT = PDB1;
 167   1      _nop_ ();
 168   1      PIO_nWR = LOW;
 169   1      PIO_nWR = HIGH;
 170   1      PIO_ADR = ADR_CMDDATB3;
 171   1      PIO_DAT = PDB0;
 172   1      _nop_ ();
 173   1      PIO_nWR = LOW;
 174   1      PIO_nWR = HIGH;
 175   1      //
 176   1      PIO_ADR = ADR_CMDSEL;   // then load the CmdSelect reg
 177   1      PIO_DAT = SLEN_LOAD;    // select the SyncLength load reg
C51 COMPILER V8.04   PIOLIB                                                                09/26/2014 14:38:04 PAGE 4   

 178   1      _nop_ ();
 179   1      PIO_nWR = LOW;
 180   1      PIO_nWR = HIGH;
 181   1      PIO_ADR = 0xFF;                 // put back to high impedance.
 182   1      PIO_DAT = 0xFF;
 183   1      }
 184          
 185          
 186          /*----- Set the DV_Count/FrameNumber counter */
 187          void
 188          pio_FrameNum(unsigned long fn)
 189          {
 190   1      piodata.l_cnt = fn;
 191   1      
 192   1      PIO_ADR = ADR_CMDDATB0;
 193   1      PIO_DAT = PDB3;
 194   1      _nop_ ();
 195   1      PIO_nWR = LOW;
 196   1      PIO_nWR = HIGH;
 197   1      PIO_ADR = ADR_CMDDATB1;
 198   1      PIO_DAT = PDB2;
 199   1      _nop_ ();
 200   1      PIO_nWR = LOW;
 201   1      PIO_nWR = HIGH;
 202   1      PIO_ADR = ADR_CMDDATB2;
 203   1      PIO_DAT = PDB1;
 204   1      _nop_ ();
 205   1      PIO_nWR = LOW;
 206   1      PIO_nWR = HIGH;
 207   1      PIO_ADR = ADR_CMDDATB3;
 208   1      PIO_DAT = PDB0;
 209   1      _nop_ ();
 210   1      PIO_nWR = LOW;
 211   1      PIO_nWR = HIGH;
 212   1      //
 213   1      PIO_ADR = ADR_CMDSEL;   // load the CmdSelect reg
 214   1      PIO_DAT = DVCNTR_LOAD;  // select the FrameCounter load reg
 215   1      _nop_ ();
 216   1      PIO_nWR = LOW;
 217   1      PIO_nWR = HIGH;
 218   1      PIO_ADR = 0xFF;
 219   1      PIO_DAT = 0xFF;
 220   1      }
 221          
 222          
 223          /*----- Set the Mode byte */
 224          void
 225          pio_DV_Mode(unsigned char mode)
 226          {
 227   1      
 228   1      PIO_ADR = ADR_MODEREG;  // one byte, write it direct to reg.
 229   1      PIO_DAT = mode;
 230   1      _nop_ ();
 231   1      PIO_nWR = LOW;
 232   1      PIO_nWR = HIGH;
 233   1      PIO_ADR = 0xFF;
 234   1      PIO_DAT = 0xFF;
 235   1      }
 236          
 237          
 238          /*-----  Set the FreeRun count-compare reg.
 239                          [the FR counter increments on AddrZero from SyncLength counter] */
C51 COMPILER V8.04   PIOLIB                                                                09/26/2014 14:38:04 PAGE 5   

 240          void
 241          pio_FRun_Count(int frc)
 242          {
 243   1      piodata.i_cnt = frc;
 244   1      
 245   1      // load count to the CmdData reg; only 2 bytes used.
 246   1      PIO_ADR = ADR_CMDDATB0;
 247   1      PIO_DAT = PDB1;
 248   1      _nop_ ();
 249   1      PIO_nWR = LOW;
 250   1      PIO_nWR = HIGH;
 251   1      PIO_ADR = ADR_CMDDATB1;
 252   1      PIO_DAT = PDB0;
 253   1      _nop_ ();
 254   1      PIO_nWR = LOW;
 255   1      PIO_nWR = HIGH;
 256   1      //
 257   1      PIO_ADR = ADR_CMDSEL;   // load the CmdSelect reg
 258   1      PIO_DAT = FRUN_LOAD;    // select the FreeRun counter load reg
 259   1      _nop_ ();
 260   1      PIO_nWR = LOW;
 261   1      PIO_nWR = HIGH;
 262   1      PIO_ADR = 0xFF;
 263   1      PIO_DAT = 0xFF;
 264   1      }
 265          
 266          // set the adjustable-clock frequency divisor
 267          void
 268          pio_clk_adj_div(int clk_adj_div)
 269          {
 270   1      piodata.i_cnt = clk_adj_div;
 271   1      
 272   1      // load count to the CmdData reg; only 2 bytes used.
 273   1      PIO_ADR = ADR_CMDDATB0;
 274   1      PIO_DAT = PDB1;
 275   1      _nop_ ();
 276   1      PIO_nWR = LOW;
 277   1      PIO_nWR = HIGH;
 278   1      PIO_ADR = ADR_CMDDATB1;
 279   1      PIO_DAT = PDB0;
 280   1      _nop_ ();
 281   1      PIO_nWR = LOW;
 282   1      PIO_nWR = HIGH;
 283   1      //
 284   1      PIO_ADR = ADR_CMDSEL;   // load the CmdSelect reg
 285   1      PIO_DAT = CLK_ADJ_DIV_LOAD;     // select the FreeRun counter load reg
 286   1      _nop_ ();
 287   1      PIO_nWR = LOW;
 288   1      PIO_nWR = HIGH;
 289   1      PIO_ADR = 0xFF;
 290   1      PIO_DAT = 0xFF;
 291   1      }
 292          
 293          /*----- Set the ACDCUs on/off control byte   */
 294          void pio_pwr_onoff(unsigned char enbits)
 295          {
 296   1      PIO_ADR = ADR_AUXO;
 297   1      PIO_DAT = enbits;
 298   1      _nop_ ();
 299   1      _nop_ ();                       // give some extra time for things to propagate thru the CPLD to the external reg.
 300   1      PIO_nWR = LOW;
 301   1      PIO_nWR = HIGH;
C51 COMPILER V8.04   PIOLIB                                                                09/26/2014 14:38:04 PAGE 6   

 302   1      PIO_ADR = 0xFF;
 303   1      PIO_DAT = 0xFF;
 304   1      }
 305          
 306          /*----- Read the ACDCUs status byte */
 307          unsigned char
 308          pio_pwr_status(void)
 309          {
 310   1      unsigned char stat;
 311   1      
 312   1      PIO_ADR = ADR_AUXI;
 313   1      PIO_nRD = LOW;
 314   1      _nop_ ();
 315   1      _nop_ ();                       // give some extra time for things to propagate thru the CPLD from the external reg.
 316   1      _nop_ ();                       // and for bus to settle
 317   1      _nop_ ();
 318   1      stat = PIO_DAT;
 319   1      PIO_nRD = HIGH;
 320   1      PIO_ADR = 0xFF;
 321   1      PIO_DAT = 0xFF;
 322   1      
 323   1      return stat;
 324   1      }
 325          
 326          
 327          /*----- not used
 328          void
 329          pio_RdSwitches()
 330          {
 331          bit sw1, sw2, sw3, sw4;
 332          
 333          sw1 = PIO_SW1;
 334          sw2 = PIO_SW2;
 335          sw3 = PIO_SW3;
 336          sw4 = PIO_SW4;
 337          
 338          //  not finished, needs to return the switch value
 339          }
 340           */
 341          
 342          
 343          /*----- not used
 344          void
 345          pio_Chk_PSCool()
 346          {
 347          bit iscool = PIO_PSCOOL;
 348          
 349          if((iscool = PIO_PSCOOL) == 0 )
 350                  printf("\r\tCOOLING FAIL?");
 351          }
 352          */
 353          
 354          
 355          /************************** EOF **********************************************/
 356          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    309    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      4    ----
C51 COMPILER V8.04   PIOLIB                                                                09/26/2014 14:38:04 PAGE 7   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
