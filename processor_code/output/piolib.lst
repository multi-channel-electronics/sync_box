C51 COMPILER V8.04   PIOLIB                                                                11/17/2006 13:18:48 PAGE 1   


C51 COMPILER V8.04, COMPILATION OF MODULE PIOLIB
OBJECT MODULE PLACED IN .\output\piolib.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE piolib.c COMPACT ROM(COMPACT) BROWSE MODP2 DEBUG OBJECTEXTEND PRINT(.\outpu
                    -t\piolib.lst) OBJECT(.\output\piolib.obj)

line level    source

   1          /*==========================================================================* 
   2           * piolib.c                                                                                                                                     * 
   3           * interface to the Mancho CPLD.                                                                                * 
   4           *==========================================================================* 
   5           * First version: RHJ 9-June-06
   6           *
   7           *
   8           */
   9          
  10          #define  PIOLIB
  11          
  12          #include <AT89c5131.h>
  13          #include <stdio.h>
  14          #include <intrins.h>
  15          
  16          #include "SyncoCmd.h"
  17          
  18          
  19          /*---------- Function prototypes */
  20          void pio_Reset(bit b);
  21          void pio_nEnable(bit b);
  22          void pio_SyncLength(unsigned long sl); 
  23          void pio_FrameNum(unsigned long fn);
  24          void pio_DV_Mode(unsigned char mode);
  25          void pio_FRun_Count(int frc);
  26          //void pio_RdSwitches();
  27          void pio_pwr_onoff(unsigned char enbits);
  28          unsigned char pio_pwr_status(void);
  29          void pio_Chk_PSCool();
  30          
  31          /*=========================================================================================*/
  32          /*---------- PIO Interface Defines; See also PIO_Interface.vhd */
  33          /* 
  34          P1.0            = PIO_Reset
  35          P1.1            = PIO_nEnable
  36          P1.2 to P1.5 = switches input [not used]
  37          P1.6            =  [not used]
  38          P1.7            =  Spare opto-isolated TTL Input. [not used]
  39                  -----------------
  40          P3.0            = RS232_RXD, 
  41          P3.1            = RS232_TXD, 
  42          P3.2 to P3.5 = Interrupts & timers, 
  43          P3.6            = PIO_nWR, 
  44          P3.7            = PIO_nRD. 
  45          */
  46          
  47          #define PIO_DAT P0
  48          #define PIO_ADR P2
  49          
  50          sbit PIO_RESET  =       P1^0;           // outputs init high, so initial state is reset,
  51          sbit PIO_nENABLE =      P1^1;           // and clocking disabled.
  52          sbit PIO_SW4    =       P1^2;           // [not used]
  53          sbit PIO_SW3    =       P1^3;           // [not used]
  54          sbit PIO_SW2    =       P1^4;           // [not used]
C51 COMPILER V8.04   PIOLIB                                                                11/17/2006 13:18:48 PAGE 2   

  55          sbit PIO_SW1    =       P1^5;           // [not used]
  56          sbit PIO_PSCOOL =       P1^7;           // [not used] [was 'cooling interlock', is now 'spare opto-TTL input']
  57          //
  58          sbit PIO_nINT0  =       P3^2;           // [not used]
  59          sbit PIO_nINT1  =       P3^2;           // [not used]
  60          sbit PIO_T0             =       P3^4;           // [not used]
  61          sbit PIO_T1             =       P3^5;           // [not used]
  62          sbit PIO_nWR    =       P3^6;           // 
  63          sbit PIO_nRD    =       P3^7;           //
  64          
  65          // PIO CPLD/Firmware register address definitions. See also PIO_Interface.vhd 
  66          #define  ADR_xxx                00 // -- X"0000"        xxx
  67          #define  ADR_CMDSEL     01 // -- X"0001"        Cmd function Select
  68          #define  ADR_MODEREG    02 // -- X"0002"        Mode Control Register
  69          #define  ADR_CMDDATB0   16 // -- X"0010"        CmdData[7..0]
  70          #define  ADR_CMDDATB1   17 // -- X"0011"        CmdData[15..8]
  71          #define  ADR_CMDDATB2   18 // -- X"0012"        CmdData[23..16]
  72          #define  ADR_CMDDATB3   19 // -- X"0013"        CmdData[31..24]
  73          #define  ADR_AUXO               32 // -- X"0020"        AuxOut
  74          #define  ADR_AUXI               33 // -- X"0021"        AuxIn
  75          //
  76          // CmdSelect reg control vaules
  77          #define  SLEN_LOAD              1       // Load SyncLength counter
  78          #define  FRUN_LOAD              2       // FreeRun counter
  79          #define  DVCNTR_LOAD    4       // DV, FrameNumber, counter
  80          //
  81          // Mode Control Select Reg., RTS_DV or FRUN_DV control bit; 1 = FR_Enable
  82          #define  MODE_DV                00 
  83          
  84          
  85          /*-------------------------------------------------------------------------------------------*/
  86          /* To write to a Mancho-CPLD reg, first write the value bytes into the CmdData reg, 
  87           * then write the appropriate select byte to the CmdSelect register.
  88           */
  89          //      if (LowAddr = ADR_CMDSEL and PIO_A = X"00" and PIO_nWR = '0') then 
  90          //              CmdWrite <= '1';
  91          //      else 
  92          //              CmdWrite <= '0';
  93          //      end if;
  94          //      SL_Load      <= CmdWrite and match(PIO_AD, (X"01"));    -- 01
  95          //      FR_Load      <= CmdWrite and match(PIO_AD, (X"02"));    -- 10
  96          //      DV_Cntr_Load <= CmdWrite and match(PIO_AD, (X"03"));    -- 11;
  97          //
  98          //  bit 0 of the ModeReg controls whether FreeRun or RTS DV is used.
  99          //      FR_Enable <= ModeReg(0);
 100          
 101          
 102          /*=========================================================================================*/
 103          /* The 8051 is big-endian, 
 104           * the cpld will be addressed as little-endian, 
 105           * so the byte order must be reversed when writing to the CPLD CMDDATA.
 106           *
 107           * In this version of SyncoCmd, P0 is used for data io, P2 for an 8 bit address
 108           */
 109          
 110          union
 111               {
 112               unsigned long l_cnt;
 113               int i_cnt;
 114               unsigned char bytes[4];
 115               }  piodata;
 116          
C51 COMPILER V8.04   PIOLIB                                                                11/17/2006 13:18:48 PAGE 3   

 117          #define PDB0 piodata.bytes[0]
 118          #define PDB1 piodata.bytes[1]
 119          #define PDB2 piodata.bytes[2]
 120          #define PDB3 piodata.bytes[3]
 121          
 122          
 123           
 124           /*-------------------------------------------------------------------------------------------*/
 125          
 126          /*-----  */
 127          void
 128          pio_Reset(bit b)
 129          {
 130   1      PIO_RESET = b;          // 
 131   1      }
 132          
 133          /*-----   */
 134          void 
 135          pio_nEnable(bit b)
 136          {
 137   1      if(b==ON) 
 138   1              PIO_nENABLE = 0;                // note that nEnable is active low
 139   1      else 
 140   1              PIO_nENABLE = 1;
 141   1      } 
 142           
 143          /*----- set the sync length count */
 144          void
 145          pio_SyncLength(unsigned long sl)  
 146          {
 147   1      piodata.l_cnt = sl;
 148   1      
 149   1      //printf("\tSL = %d", piodata.i_cnt);
 150   1      
 151   1      // first load the count to the CmdData reg.
 152   1      PIO_ADR = ADR_CMDDATB0;
 153   1      PIO_DAT = PDB3;
 154   1      _nop_ ();
 155   1      PIO_nWR = LOW;
 156   1      PIO_nWR = HIGH;
 157   1      PIO_ADR = ADR_CMDDATB1;
 158   1      PIO_DAT = PDB2;
 159   1      _nop_ ();
 160   1      PIO_nWR = LOW;
 161   1      PIO_nWR = HIGH;
 162   1      PIO_ADR = ADR_CMDDATB2;
 163   1      PIO_DAT = PDB1;
 164   1      _nop_ ();
 165   1      PIO_nWR = LOW;
 166   1      PIO_nWR = HIGH;
 167   1      PIO_ADR = ADR_CMDDATB3;
 168   1      PIO_DAT = PDB0;
 169   1      _nop_ ();
 170   1      PIO_nWR = LOW;
 171   1      PIO_nWR = HIGH;
 172   1      //
 173   1      PIO_ADR = ADR_CMDSEL;   // then load the CmdSelect reg
 174   1      PIO_DAT = SLEN_LOAD;    // select the SyncLength load reg
 175   1      _nop_ ();
 176   1      PIO_nWR = LOW;
 177   1      PIO_nWR = HIGH;
 178   1      PIO_ADR = 0xFF;                 // put back to high impedance.
C51 COMPILER V8.04   PIOLIB                                                                11/17/2006 13:18:48 PAGE 4   

 179   1      PIO_DAT = 0xFF;
 180   1      }
 181          
 182          
 183          /*----- Set the DV_Count/FrameNumber counter */
 184          void
 185          pio_FrameNum(unsigned long fn)
 186          {
 187   1      piodata.l_cnt = fn;
 188   1      
 189   1      PIO_ADR = ADR_CMDDATB0;
 190   1      PIO_DAT = PDB3;
 191   1      _nop_ ();
 192   1      PIO_nWR = LOW;
 193   1      PIO_nWR = HIGH;
 194   1      PIO_ADR = ADR_CMDDATB1;
 195   1      PIO_DAT = PDB2;
 196   1      _nop_ ();
 197   1      PIO_nWR = LOW;
 198   1      PIO_nWR = HIGH;
 199   1      PIO_ADR = ADR_CMDDATB2;
 200   1      PIO_DAT = PDB1;
 201   1      _nop_ ();
 202   1      PIO_nWR = LOW;
 203   1      PIO_nWR = HIGH;
 204   1      PIO_ADR = ADR_CMDDATB3;
 205   1      PIO_DAT = PDB0;
 206   1      _nop_ ();
 207   1      PIO_nWR = LOW;
 208   1      PIO_nWR = HIGH;
 209   1      //
 210   1      PIO_ADR = ADR_CMDSEL;   // load the CmdSelect reg
 211   1      PIO_DAT = DVCNTR_LOAD;  // select the FrameCounter load reg
 212   1      _nop_ ();
 213   1      PIO_nWR = LOW;
 214   1      PIO_nWR = HIGH;
 215   1      PIO_ADR = 0xFF;
 216   1      PIO_DAT = 0xFF;
 217   1      }
 218          
 219          
 220          /*----- Set the Mode byte */
 221          void
 222          pio_DV_Mode(unsigned char mode)
 223          {
 224   1      
 225   1      PIO_ADR = ADR_MODEREG;  // one byte, write it direct to reg.
 226   1      PIO_DAT = mode;
 227   1      _nop_ ();
 228   1      PIO_nWR = LOW;
 229   1      PIO_nWR = HIGH;
 230   1      PIO_ADR = 0xFF;
 231   1      PIO_DAT = 0xFF;
 232   1      }
 233          
 234          
 235          /*-----  Set the FreeRun count-compare reg. 
 236                          [the FR counter increments on AddrZero from SyncLength counter] */
 237          void
 238          pio_FRun_Count(int frc)
 239          {
 240   1      piodata.i_cnt = frc;
C51 COMPILER V8.04   PIOLIB                                                                11/17/2006 13:18:48 PAGE 5   

 241   1      
 242   1      // load count to the CmdData reg; only 2 bytes used.
 243   1      PIO_ADR = ADR_CMDDATB0;
 244   1      PIO_DAT = PDB1;
 245   1      _nop_ ();
 246   1      PIO_nWR = LOW;
 247   1      PIO_nWR = HIGH;
 248   1      PIO_ADR = ADR_CMDDATB1;
 249   1      PIO_DAT = PDB0;
 250   1      _nop_ ();
 251   1      PIO_nWR = LOW;
 252   1      PIO_nWR = HIGH;
 253   1      //
 254   1      PIO_ADR = ADR_CMDSEL;   // load the CmdSelect reg
 255   1      PIO_DAT = FRUN_LOAD;    // select the FreeRun counter load reg
 256   1      _nop_ ();
 257   1      PIO_nWR = LOW;
 258   1      PIO_nWR = HIGH;
 259   1      PIO_ADR = 0xFF;
 260   1      PIO_DAT = 0xFF;
 261   1      }
 262          
 263          
 264          /*----- Set the ACDCUs on/off control byte   */
 265          void pio_pwr_onoff(unsigned char enbits)
 266          {
 267   1      PIO_ADR = ADR_AUXO;
 268   1      PIO_DAT = enbits;
 269   1      _nop_ ();
 270   1      _nop_ ();                       // give some extra time for things to propagate thru the CPLD to the external reg.
 271   1      PIO_nWR = LOW;
 272   1      PIO_nWR = HIGH;
 273   1      PIO_ADR = 0xFF;
 274   1      PIO_DAT = 0xFF;
 275   1      }
 276          
 277          /*----- Read the ACDCUs status byte */
 278          unsigned char
 279          pio_pwr_status(void)
 280          {
 281   1      unsigned char stat;
 282   1      
 283   1      PIO_ADR = ADR_AUXI;
 284   1      PIO_nRD = LOW;
 285   1      _nop_ ();
 286   1      _nop_ ();                       // give some extra time for things to propagate thru the CPLD from the external reg.
 287   1      _nop_ ();                       // and for bus to settle
 288   1      _nop_ ();
 289   1      stat = PIO_DAT;
 290   1      PIO_nRD = HIGH;
 291   1      PIO_ADR = 0xFF;
 292   1      PIO_DAT = 0xFF;
 293   1      
 294   1      return stat;
 295   1      }
 296          
 297          
 298          /*----- not used
 299          void
 300          pio_RdSwitches()
 301          {
 302          bit sw1, sw2, sw3, sw4;
C51 COMPILER V8.04   PIOLIB                                                                11/17/2006 13:18:48 PAGE 6   

 303          
 304          sw1 = PIO_SW1;
 305          sw2 = PIO_SW2;
 306          sw3 = PIO_SW3;
 307          sw4 = PIO_SW4;
 308          
 309          //  not finished, needs to return the switch value
 310          }
 311           */
 312          
 313          
 314          /*----- not used 
 315          void 
 316          pio_Chk_PSCool()
 317          {
 318          bit iscool = PIO_PSCOOL;
 319          
 320          if((iscool = PIO_PSCOOL) == 0 )
 321                  printf("\r\tCOOLING FAIL?");
 322          }
 323          */
 324          
 325          
 326          /************************** EOF **********************************************/
 327          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    261    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      4    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
