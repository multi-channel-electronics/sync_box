C51 COMPILER V8.02   CMDDICT                                                               02/23/2010 09:00:14 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE CMDDICT
OBJECT MODULE PLACED IN .\output\cmddict.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE cmddict.c COMPACT ROM(COMPACT) BROWSE MODP2 DEBUG OBJECTEXTEND PRINT(.\outp
                    -ut\cmddict.lst) OBJECT(.\output\cmddict.obj)

line level    source

   1          /*==========================================================================*
   2           * cmddict.c                                                                                                                    *
   3           * Command dictionary & command parse routines.                                                         *
   4           *==========================================================================*
   5           * First version for SC2: RHJ 1-May-06
   6           *
   7           */
   8          
   9          
  10          /*==========================================================================*/
  11          #define CMDDICT
  12          
  13          #include <stdio.h>
  14          #include <stddef.h>
  15          #include <stdlib.h>
  16          #include <string.h>
  17          #include <ctype.h>
  18          #include "SyncoCmd.h"
  19          
  20          
  21          /*========== Support Routines Function prototypes   ========================*/
  22          
  23          int cd_tokenize(char *str);
  24          int cd_parse(CMD_ENTRY cmd_dict[], int dict_size);
  25          char *nxttoken(void);
  26          int cd_arg_i(void);
  27          int cd_arg_ul(unsigned long *ul);
  28          void cd_help();
  29          
  30          //code char *prtWHAT[] = "\tWHAT? \"%s\"";
  31          
  32          // parameter hint strings for help. See cd_help() function definition below.
  33          code char pram[] = " n";
  34          code char nopr[] = "  ";
  35          
  36          /*========== command dictionary =============================================*/
  37          
  38          code CMD_ENTRY cmd_dict[] =
  39                  {
  40                          { "h",          cd_help,                        nopr,   "help, this stuff" },
  41                          { "?",          get_Status,                     nopr,   "get Mancho Status" },
  42                          { "rl",         set_Row_Len,            pram,   "set Row_Len\tn = 1 to 4095" },
  43                          { "nr",         set_Num_Rows,           pram,   "set Num_Rows\tn = 1 to 63" },
  44                          { "rt",         set_RTS_Mode,           nopr,   "set RTS_Mode" },
  45                          { "fr",         set_FR_Mode,            pram,   "set FreeRun Mode\tn = 1 to 4095" },
  46                          { "fn",         set_Frame_Num,          pram,   "set Frame Sequence Number\tn = 0 to 2^32-1" },
  47                          { "ckd",    set_clk_adj_div,    pram,   "set the divisor for the adjustable clock output (50MHz/ckd)\tn 
             -= 1 to 255 (default=10)"},
  48                          { "st",         set_Disable,            nopr,   "stop, disable Manchout" },
  49                          { "go",         set_Enable,                     nopr,   "enable Manchout" },
  50                          { "dpa",        pwr_disable_all,        nopr,   "pwr disable all" },
  51                          { "dpu",        pwr_disable_unit,       pram,   "pwr disable unit\tn = 0 to 7" },
  52                          { "epu",        pwr_enable_unit,        pram,   "pwr enable unit \tn = 0 to 7" },
  53                          { "pof",        pwr_onoff,                      nopr,   "get ACDCU_onoff cntl byte" },
C51 COMPILER V8.02   CMDDICT                                                               02/23/2010 09:00:14 PAGE 2   

  54                          { "ps",         pwr_status,                     nopr,   "get ACDCU status" },
  55                          { "re",         do_ResetAll,            nopr,   "Reset all to defaults" },
  56          //              { "ron",        ResetOn,                        nopr,   "Reset on" },
  57          //              { "rof",        ResetOff,                       nopr,   "Reset off" },
  58                  };
  59          
  60          code int dict_size = (sizeof(cmd_dict) / sizeof(CMD_ENTRY));
  61          
  62          
  63          /*========== Parse header definitions =======================================*/
  64          
  65          #define MAXTOKEN 12
  66          
  67          static char *tokenpbuf[MAXTOKEN];       /* array of pointers to tokens */
  68          static char **tokenv;                           /* pointer to current token (pointer to token pointer) */
  69          
  70          
  71          /*----- chop a command line string into separate word strings (tokens)*/
  72          int
  73          cd_tokenize(char *str)
  74          {
  75   1              extern char *tokenpbuf[];
  76   1              extern char **tokenv;
  77   1              int i=0;                                                                                                        // current token (index)
  78   1      
  79   1              tokenpbuf[i++] = strtok(str," \n\r");                                           // setup strtok for the scan
  80   1              while ((tokenpbuf[i] = strtok(NULL," \n\r")) != NULL)           // scan the rest of the string
  81   1                      { i++; if(i >= (MAXTOKEN-1))  break; }                                  // if too many tokens, stop the scan
  82   1      
  83   1              tokenpbuf[i] = 00 ;                                                                                     // terminate the list of pointers
  84   1              tokenv = &tokenpbuf[0];                                                                         // set pointer to first token
  85   1      }
  86          
  87          
  88          /*----- parse a command line */
  89          int
  90          cd_parse(CMD_ENTRY cmd_dict[], int dict_size)
  91          {
  92   1              int entry=0, n;
  93   1              char *token;
  94   1      
  95   1              while((token = nxttoken()) != 0 ) {
  96   2                      //if (strncmp(token,"#",1)==0) break;           //
  97   2      
  98   2                      /* look for the current token in the command table */
  99   2                      for (entry=0; entry < dict_size; entry++ ) {
 100   3                              n = strlen(cmd_dict[entry].nmem);
 101   3                              if(strncmp(token, cmd_dict[entry].nmem, n)==0) break;   // if token is found, stop looking
 102   3                      }
 103   2      
 104   2      
 105   2                      if (entry < dict_size)
 106   2                              (cmd_dict[entry].fcn)();                        // if token found, execute cmd function
 107   2                      else {
 108   3                              printf("\tWHAT? \"%s\"", token);        // else send error message,
 109   3                              break;                                                          //and stop parsing
 110   3                      }
 111   2              }
 112   1      }
 113          
 114          
 115          /*-----  supply pointer to token or 00, & maybe increment the token vector */
C51 COMPILER V8.02   CMDDICT                                                               02/23/2010 09:00:14 PAGE 3   

 116          char *
 117          nxttoken()
 118          {
 119   1              extern char **tokenv;
 120   1      
 121   1              if(*tokenv != 0)
 122   1                      return(*tokenv++);
 123   1              else
 124   1                      return(0);
 125   1      }
 126          
 127          
 128          /*----- return an integer arg from the token list */
 129          int
 130          cd_arg_i()
 131          {
 132   1              char *nxtarg = nxttoken();
 133   1      
 134   1              if (nxtarg == NULL )
 135   1                      { return(-2); }                         // if rtn = -2 [= no arg]
 136   1      
 137   1              if (isdigit(*nxtarg) == 0)
 138   1                      {
 139   2                      printf("\tWHAT? \"%s\"", nxtarg);
 140   2                      return(-1);                                     // if rtn = -1 [= not a digit arg]
 141   2                      }
 142   1      
 143   1              return(atoi(nxtarg));
 144   1      }
 145          
 146          
 147          /* return an unsigned long arg from the token list */
 148          int
 149          cd_arg_ul(unsigned long *ul)
 150          {
 151   1              char *nxtarg = nxttoken();
 152   1          char *p;
 153   1      
 154   1              if (nxtarg == NULL)
 155   1                      { return(-2); }
 156   1      
 157   1              if (isdigit(*nxtarg) == 0)
 158   1                      {
 159   2                      printf("\tWHAT? \"%s\"", nxtarg);
 160   2                      return(-1);
 161   2                      }
 162   1      
 163   1              *ul = strtoul(nxtarg, &p, 10);
 164   1              return(1);
 165   1      
 166   1      }
 167          
 168          /*----- ouput the command table nmemonics and help strings */
 169          void
 170          cd_help()
 171          {
 172   1              int entry;
 173   1      
 174   1              for (entry=0; entry < dict_size; entry++ )
 175   1                      {
 176   2                      printf("\r\t %s%s\t\t%s", cmd_dict[entry].nmem, cmd_dict[entry].param, cmd_dict[entry].help );
 177   2                      }
C51 COMPILER V8.02   CMDDICT                                                               02/23/2010 09:00:14 PAGE 4   

 178   1      }
 179          
 180          
 181          
 182          /*==================== End Of File ======================================== */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    868    ----
   CONSTANT SIZE    =    713    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     39      26
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
